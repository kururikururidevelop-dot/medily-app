# 認証の仕組みについて

Medilyアプリ（本プロジェクト）では、認証基盤として **Firebase Authentication** を採用しています。
LINEログイン機能を提供しており、サーバー側でLINE認証を行い、Firebaseのカスタムトークンを発行してログイン状態を管理しています。

## 認証フロー概略

1.  **LINEログイン（OAuth 2.0）**
    *   ユーザーが「LINEでログイン」ボタンを押すと、LINEの認証画面へ遷移します。
    *   認証後、LINEからコールバックURLへ戻り、サーバー側でアクセストークンを取得・検証します。
2.  **Firebase認証（Custom Token）**
    *   サーバー側はLINEユーザーID（`L` プレフィックス付き）を元に、Firebase Admin SDKを使って **カスタムトークン** を発行します。
    *   このカスタムトークンをクライアント（ブラウザ）に渡します。
3.  **クライアントログイン**
    *   クライアント側で `signInWithCustomToken` を実行し、Firebase Authのセッションを確立します。
    *   これ以降、Firebase SDKが「IDトークン（短期有効）」と「リフレッシュトークン（長期有効）」を内部のIndexedDB等で安全に管理します。

## LocalStorage の役割と `userId`

ユーザーからよくある質問として、「なぜ `localStorage` に `userId` だけを持つのか？（トークンは持たなくていいのか？）」という点があります。

### Q. なぜ `localStorage` には `userId` だけ保存しているのですか？

**A. セキュリティと整合性のために、認証トークンの管理はFirebase SDKに任せ、`localStorage` はあくまで「表示用のキャッシュ」として利用しているためです。**

#### 1. トークンの管理（Firebase SDKの役割）
認証トークン（IDトークン）は、有効期限が1時間と短く設定されており、期限切れのたびに更新が必要です。
Firebase SDKはこの複雑なライフサイクル（保存、自動更新、署名検証）をすべて自動で安全に行ってくれます。
自前で `localStorage` にトークンを保存してしまうと、XSS（クロスサイトスクリプティング）攻撃で盗まれるリスクが高まるほか、期限切れのハンドリングやリフレッシュ処理を自前で実装する必要が出てきます。

したがって、**APIリクエストを送る際は、その都度 `user.getIdToken()` を呼び出して最新のトークンを取得し、Authorizationヘッダーにセットする** のが最も安全で確実な方法です。

#### 2. LocalStorage の役割（UI最適化）
一方で、`localStorage` に `userId` や簡易的なフラグ（`token`という名前の存在確認用フラグなど）を保存している理由は、**UX（ユーザー体験）の向上**のためです。
*   **画面のちらつき防止**: Firebase Authの初期化（`onAuthStateChanged`）は非同期で時間がかかるため、これだけを待っていると画面が一瞬真っ白になったり、ログイン画面が表示されてしまったりします。`localStorage` に値があれば「ログイン済み」とみなして即座に画面を表示（またはローディング表示）することができます。
*   **簡易アクセス**: アプリケーション内の様々な箇所で「自分のユーザーID」が必要になった際、非同期でFirebaseから取得するよりも、同期的に `localStorage.getItem('userId')` で取得できたほうがコードがシンプルになる場合があります（ただし、信頼できるデータが必要なサーバー通信時は除く）。

### まとめ
*   **セキュリティ（API通信・データ保護）**: Firebase Auth (`user.getIdToken()`) を使用。
*   **UI表示・画面遷移制御**: `localStorage` の `userId` やフラグを補助的に使用。

このように役割を分担することで、セキュリティと使い勝手の両立を図っています。

### 参考：IndexedDB とは？

**IndexedDB** は、ブラウザに標準搭載されているデータベース（NoSQL型）です。
Firebase SDK がトークン保存場所に LocalStorage ではなく IndexedDB を採用している理由には、以下のような特徴があります。

*   **大容量・高機能**: LocalStorage（文字列しか保存できず、容量も5MB程度）に対し、IndexedDBはオブジェクトやバイナリデータをそのまま保存でき、容量制限もGB単位と非常に大きいです。
*   **非同期処理**: LocalStorage は読み書きが完了するまで画面の描画を止めてしまいます（同期的）が、IndexedDB はバックグラウンドで処理される（非同期）ため、アプリの動作が重くなりません。
*   **Service Worker 対応**: LocalStorage は Service Worker（バックグラウンドで動くプログラム）からアクセスできませんが、IndexedDB はアクセス可能です。これにより、アプリが開かれていない状態でも認証状態を維持・更新するなど、PWA（Progressive Web App）としての高度な機能を実現できます。

# 認証設計メモ

## 画面別の認証要否の整理

- その画面を認証する必要があるかどうかを「認証要否」に記載

| 画面ID | 画面名               | 認証要否 |
| ------ | -------------------- | ---- | 
| A010   | PRサイトTOP          | 不要  |
| A020   | OAuth選択            | 不要  |
| A030   | 初回プロフィール登録 | 必要  |
| A040   | ホーム               | 必要  |
| A041   | 質問一覧（公開）     | 不要  |
| D010   | マイページ           | 必要  |
| D020   | プロフィール編集     | 必要  |
| E010   | 質問一覧（自分）     | 必要  |
| E020   | 回答一覧（自分）     | 必要  |
| E030   | 質問詳細・回答       | 必要  |
| F010   | 設定                 | 必要  |
| F020   | 利用規約             | 不要  |
| F030   | プライバシーポリシー | 不要  |
| F040   | 退会画面             | 必要  |
| Q010   | 質問投稿             | 必要  |
| Q011   | 質問投稿確認         | 必要  |
| Q012   | 質問投稿完了         | 必要  |
| Q020   | 回答記入             | 必要  |
| Q021   | 回答記入確認         | 必要  |
| Q022   | 回答記入完了         | 必要  |

## メンバー登録の定義
- usersにレコードがない：未登録
- usersにレコードがあり、isProfileCompleted=false：仮登録
- usersにレコードがあり、isProfileCompleted=true：登録済

## 認証フロー
- Medilyアプリの画面にアクセスする
  - 当該画面が認証要否＝不要
    - 当該画面を表示する
  - 当該画面が認証要否＝必要
    - クライアント認証（firebase認証）状態のチェック
      -  クライアント認証＝認証済
              - 当該画面を表示する
      -  クライアント認証＝認証されていない
          - OAuth認証画面へ遷移→LINE認証
            - メンバー登録＝未登録
              - LINEの情報でusers追加→仮登録へ
              - 初回プロフィール登録画面へ遷移する
            - メンバー登録＝仮登録
              - LINEの情報でusers更新→仮登録のまま
              - プロフィール編集画面へ遷移する
            - メンバー登録＝登録済
              - 当該画面を表示する