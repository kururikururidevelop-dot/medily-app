# 処理方式設計書

本書は本システム（Web + LINE Messaging API + Firebase）を開発・運用するための処理方式設計をまとめる。実行環境（インフラ）、開発環境（ライブラリ）、UI/UX 実装方式、フロントエンド処理方式、バックエンド処理方式を網羅する。モックの作成に関する注意点も含む。

---

## 1. 実行環境（インフラ）

- フロントエンド（Web）
  - Next.js（静的最適化 + 必要箇所で SSR）を Vercel または Firebase Hosting にデプロイ。
  - HTTPS でホスト（質問投稿・回答記入等の全機能を Web で提供）。
- バックエンド
  - Firebase
    - Firestore：主要データ（questions, answers, users, contributions, thank_counts）
    - Cloud Functions（Node.js 18）：LINE webhook、マッチング、イベント処理、集計バッチ
    - Cloud Storage：画像、生成アセット（例：貢献度グラフィック PNG/SVG の保存）
    - Firebase Auth（必要に応じて）：ユーザー管理
  - 必要に応じて Cloud Run を利用（重いバッチ処理、画像生成、外部連携）
- ネットワーク／CDN
  - Hosting の CDN（Vercel / Firebase Hosting）または Cloud CDN を利用
  - 静的アセットはキャッシュ制御（Cache-Control）・バージョニング
- シークレット管理
  - Firebase Functions の環境変数 (`functions:config:set`) または Secret Manager で LINE チャネルシークレット等を管理
- ログ・監視
  - Cloud Logging / Error Reporting を用いる
  - パフォーマンス指標（Lighthouse、PageSpeed）を定期測定

---

## 2. 開発環境（ライブラリ）

推奨パッケージ（React / Next ベース）

- 基本スタック
  - `next`, `react`, `react-dom`, `typescript`
  - `tailwindcss`, `postcss`, `autoprefixer`
  - `eslint`, `prettier`, `husky`, `lint-staged`
- HTTP / データ取得
  - `axios` または `fetch`（`swr` / `@tanstack/react-query` を推奨）
- LINE
  - `@line/bot-sdk`（サーバー側での Messaging API 呼び出し、通知配信）
- Firebase
  - `firebase`（クライアント SDK）
  - `firebase-admin`（サーバー側管理用）
  - `firebase-functions`
- UI / アイコン
  - `@mui/material`（必要時）、ただしデザインは Tailwind ベースに統一
  - Material Icons: SVG ベースで取り込み（後述）
  - 進捗: `public/icons` に SVG アイコンを追加済み。モック内の font 参照を順次 SVG に置換し完了（docs/30_画面イメージ）。
- 画像 / 生成
  - `sharp`（サーバー側での画像処理が必要な場合）
  - `puppeteer` / `playwright`（レンダリングから PNG を生成する場合）
- テスト
  - `jest`, `@testing-library/react`, `msw`（API モック）
  - E2E: `playwright` または `cypress`
- その他
  - `d3` / `chart.js`（貢献度グラフィックを動的描画する場合）
  - `dayjs`（日付処理）
  - `sharp`（画像処理）

---

## 3. UI／UX 実装方式

- デザイン方針
  - モックは Tailwind ベースで作成（コンポーネント設計に従う）
  - 画像はモック段階はローカル参照（`public/` 配下）で保存
  - Material Icons は SVG 化したものを個別コンポーネントとして利用（`/icons/*.svg` → React コンポーネント）
  - ダークモード
    - 推奨：OS のプリファレンス（`prefers-color-scheme`）に追従し、アプリ内スイッチ（`dark` クラス付与）で上書き可能にする
    - ユーザーの選択は `localStorage` とユーザープロファイル（同期が必要な場合）に保存
  - レイアウトはコンポーネント単位（Atomic/Design System）で整理
- Tailwind 注意点（モック）
  - Tailwind はビルド時にローカルで CSS を生成（Purge / JIT を有効にして未使用クラスを削除）
  - `tailwind.config.js` の `content` にプロジェクト全ソースパスを含める
- 画像/アイコン取り扱い
  - モック時点では全てローカル保存（`public/images` / `public/icons`）で参照
  - 本番では Cloud Storage + CDN を使用
- SEO / meta / OGP
  - Next.js の `Head` を用いてページごとに `meta`（title, description, og:title, og:description, og:image）を設定
  - PR サイトは SSG（getStaticProps）を利用して SEO を確保
- パフォーマンス・アクセシビリティ
  - 画像最適化（`next/image` / `Image` コンポーネントでローカル画像を最適化）
  - 重要リソースのプリロード（preload）・遅延ロードの導入
  - Lighthouse 指標を満たすことを目標
- モックと機能設計の不整合
  - モックは視覚的検証が目的のため、機能設計書と一時的に不整合があることを許容する（最終実装時に整合化）

---

## 4. フロントエンド処理方式

- 技術構成
  - Next.js（App Router）＋ React コンポーネント
  - 状態管理：`React Context`（認証・UI 状態） + `swr`/`react-query`（データフェッチ・キャッシュ）
  - UI ライブラリ：Tailwind ベースの独自コンポーネント（必要時に MUI の React コンポーネント）
- 認証・ユーザー識別
  - LINE OAuth で取得した ID/プロフィールを Firebase Auth と連携
  - 未認証ユーザーが Q020（回答記入）にアクセスした場合は OAuth フローを開始
- 質問投稿ワークフロー（Q010 → Q011 → Q012）
  1. Q010: ユーザーが Web 上で質問を入力 → フロントがバリデーション
  2. Q011: 入力内容を確認画面で表示（読み取り専用）
  3. Q012: フロントは POST `/api/questions` へ送信 → 成功時は完了画面表示
  4. 投稿後、マッチングした回答者に LINE で通知配信（Q020 へのリンク付き）
- 回答記入ワークフロー（Q020 → Q021 → Q022）
  1. Q020: LINE 通知から URL パラメータ（?questionId=XXX）付きで遷移
  2. 未認証の場合は OAuth フローを開始、認証後 Q020 に戻る
  3. Q020: 回答内容を入力（選択肢、場所、URL、コメント）→ フロントがバリデーション
  4. Q021: 入力内容を確認画面で表示（読み取り専用）
  5. Q022: フロントは POST `/api/answers` へ送信 → 成功時は完了画面表示
  6. 送信後、質問者に LINE で回答通知を配信
- 回答表示ワークフロー
  - 質問者は E010（質問一覧）で自分の質問と回答を確認
  - 回答者は E020（回答一覧）で自分の回答履歴を確認
  - `swr`/`react-query` でポーリングまたはリアルタイムアップデート（Firestore SDK のリアルタイムリスナー）を採用
- 貢献度ダッシュボード（E020）
  - クライアントは `GET /api/contributions/{userId}` で集計結果（ツリー成長ステータス、サンキュー数、カテゴリ別実績）を取得
  - 表示は SVG/Canvas を利用して動的に描画。軽量化のためサーバー側で SVG を生成してキャッシュする選択肢も用意
- 画像／アセット取り扱い（モック）
  - ローカル画像は `public/images` 配下に配置。`next/image` を使って最適化（ただしモック段階では開発利便性を優先）
- ダークモードの実装
  - CSS 変数または Tailwind `dark` クラスで色を切り替え
  - デフォルトは OS 優先、ユーザーの切り替えはクライアント側で状態管理

---

## 5. バックエンド処理方式

- 技術構成
  - Firebase Cloud Functions（Node.js 18）
  - Firestore（ドキュメント設計）
  - Firebase Admin（サーバ側操作）
  - @line/bot-sdk（Messaging API 用）
- データフロー（主な処理）
  - 質問作成（Q010 → Q011 → Q012）
    1. Frontend（Q012）→ API (`/api/questions`) → Functions が受け取り Firestore に保存
    2. Functions がマッチングロジックを実行、候補に LINE Push（`@line/bot-sdk`）で通知（Q020 へのリンク付き）
    3. 通知には URL パラメータ（?questionId=XXX）を含める
  - 回答受信（Q020 → Q021 → Q022）
    1. Frontend（Q022）→ API (`/api/answers`) → Functions が受け取り Firestore に保存
    2. Functions が AI チェック（NGワード、診断行為、誹謗中傷）を実行
    3. 保存トリガーで個別スレッドの集約・ステータス更新・貢献度更新を実行
    4. 回答者の貢献集計は Atomic なトランザクションで更新（Firestore トランザクション）
    5. Functions が質問者に LINE Push で回答通知を配信
  - AI チェック
    - Q022（質問投稿確定）および Q022（回答送信確定）時に LLM ベースのチェック（NGワード、診断行為、誹謗中傷）を実行
    - 実装方法：Functions 内で LLM API（外部 API or GCP Vertex AI）呼び出しを行い、違反時は保存をブロックまたはフラグ付け
  - 貢献度画像生成
    - 選択肢：
      - クライアント描画（SVG/CANVAS）→ 軽量で即時反映（D010、E020）
      - サーバー描画（Node + Canvas / Puppeteer）→ PNG/SVG 生成して Cloud Storage に保存・配信（E020 の高速キャッシュ向け）
- バッチ処理・集計
  - Cloud Functions（cron / scheduled functions）で日次／週次集計を実行し、ランキングや履歴を生成
- エラー処理・再試行
  - LINE Push API の失敗や外部 API 呼び出しは再試行キュー（Pub/Sub / Retry）で対処
- セキュリティ
  - Firestore セキュリティルールで読み書き制御
  - Functions は最小権限で動作（サービスアカウント権限を限定）
  - LINE 署名検証、入力バリデーションを徹底

---

## 6. デプロイ / CI（推奨ワークフロー）

- GitHub Actions を用いた CI
  - `lint` → `test` → `build` → `deploy`（Vercel / Firebase Functions）
  - 本番デプロイ前にステージング環境で E2E テストを実施
- デプロイ先
  - Next.js: Vercel または Firebase Hosting (SSG/SSR サポート)
  - Functions: Firebase Functions（webhook & server-side ロジック）
  - Storage: Firebase Cloud Storage

---

## 7. 追加の技術的備考・推奨ライブラリまとめ

- Frontend
  - `next`, `react`, `tailwindcss`, `@tailwindcss/forms`, `swr`/`@tanstack/react-query`
- Backend
  - `firebase-admin`, `firebase-functions`, `@line/bot-sdk`, `sharp`（画像処理）
- Testing/CI
  - `jest`, `@testing-library/react`, `playwright` or `cypress`, `msw`
- Graphics
  - `d3`, `chart.js`（クライアント描画）
  - `puppeteer` / `node-canvas`（サーバー描画）

---

## 8. モック作成時の注意（再掲）

- Tailwind はビルド時にローカル生成（Purge 有効）
- Material Icons は SVG 化してローカル参照
- 画像はすべて `public/` にローカル保存して参照
- ダークモードは OS 連動をデフォルト、アプリ内スイッチを設ける
- レイアウトはコンポーネント設計前提で整理
- 外部ライブラリは React 版を使用
- SEO/meta/OGP を追加（PRサイトは SSG）
- 最適化されたビルドでページ速度を確保
- モックはデザイン検証が主目的のため、機能設計との部分的不整合がある前提で作成

### モックと本番実装の扱い（注記）
* モックは開発効率を優先し、CDN 配信の Tailwind や Google Fonts（Material Symbols）を利用する場合がある点を許容する。
* ただし、本番実装では以下の点を必ず満たすこと。
  - Tailwind はローカルでビルド（JIT/Purge を有効）し、不要なユーティリティを除去すること。
  - Material Icons はフォント依存を避け、SVG 化して `/public/icons` 等で管理し、可能なら React コンポーネント化すること。
  - 画像はモック段階ではローカル参照でも良いが、本番では Cloud Storage + CDN で配信し、適切なキャッシュ制御を行うこと。
  - ダークモードは OS プリファレンスに追従しつつ、アプリ内で明示的に切り替えられる UI を提供すること（設定保存は localStorage／サーバ同期）。
  - SEO/OGP はモック確認後に Next.js の `Head` で必ず設定すること（PR サイトは SSG を適用）。
  - モックから本番へ移行する際には、コンポーネント化・アクセシビリティ・パフォーマンス（Lighthouse）チェックリストを実施すること。
* 推奨ワークフロー（モック→本番）:
  1. モックでデザイン確認（CDN 設定可）
  2. コンポーネント化（React + Tailwind）→ Tailwind ローカルビルドに切替
  3. アイコンを SVG に移行、画像は `public/` からクラウドへ移行
  4. SEO/OGP を追加、パフォーマンス改善を実施
  5. ステージングで E2E と Lighthouse 検証、問題なければ本番デプロイ

* 補足: モックと処理方式設計の不整合は許容範囲だが、仕様実装時に必ず差し戻しと整合化レビューを実施すること。
