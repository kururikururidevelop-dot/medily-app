# 処理方式設計書

**医療クローズド相談マッチングサービス**
バージョン：1.0
作成日：2025-12-07

---

## 目的

質問投稿〜マッチング〜回答〜チャット（逆質問／再質問含む）までの**処理方式（実装レベル）**を明確化する。
開発者が実装できるレベルのアーキテクチャ、状態遷移、アルゴリズム、インフラ前提を含む。

---

## 目次

1. 概要サマリ
2. 前提（開発環境・インフラ）
3. 高レベルアーキテクチャ
4. データモデル（主なコレクション／テーブル）
5. 状態遷移図（質問／スレッド／バッチ）
6. 主な処理フロー（シーケンス）
7. マッチング＆通知アルゴリズム（擬似コード）
8. バッチ配信／フォールバック戦略
9. チャット（仲介）実装詳細（逆質問含む）
10. 同期・排他・整合性対策（コンカレンシー）
11. エラーハンドリング／再試行ポリシー
12. セキュリティ・プライバシー要件
13. 運用・モニタリング・バックアップ
14. テスト方針（単体・E2E）
15. 参考API一覧（主要エンドポイント）
16. 付録：Firestoreインデックス／推奨パラメータ

---

## 1. 概要サマリ

* 質問者は質問を投稿 → システムが候補回答者をスコアリングし**バッチ化**して通知。
* 回答者が回答（初回回答）を送ると**1対1の仲介スレッド**を生成し、そのスレッドで以降のやり取り（追加質問／逆質問／再質問）を行う。
* LINE/Xは**通知経路**として使い、実メッセージはシステムが管理。
* データストアは Firestore 推奨（スケーラビリティとリアルタイム性）。Cloud Functions + Cloud Tasks による非同期制御を組み合わせる。

---

## 2. 前提（開発環境・インフラ）

最低限の前提環境（想定）：

* フロントエンド：Next.js（React）
* バックエンド：Firebase（Authentication, Firestore, Cloud Functions, Cloud Tasks）, または同等のサーバレス構成
* Hosting：Vercel or Firebase Hosting
* 通知：LINE Messaging API、X（旧Twitter）API（DM送信権限）
* CI/CD：GitHub Actions（テスト→ビルド→デプロイ）
* ログ/監視：Stackdriver（Cloud Monitoring）、Sentry（アプリエラー）
* Storage：GCS（画像・バックアップ）
* Optional：Redis（高負荷時のキュー／スコアリングキャッシュ）

理由：Firebaseはリアルタイム更新、認証、サーバレストリガー、簡易なアクセス制御に優れるため初期実装に適する。

---

## 3. 高レベルアーキテクチャ

```
[ユーザーApp] <--> [API Gateway / Next.js] <--> [Firestore]
                                      \
                                       -> [Cloud Functions / Cloud Tasks] -> [LINE/X API]
                                       -> [Background Worker / Scoring Service (optional Redis)]
                                       -> [Monitoring / Logging]
```

役割：

* Frontend: UI, onSnapshotによるリアルタイム受信表示
* Firestore: 永続データ（questions, threads, messages, batches, matches）
* Cloud Functions: マッチ候補算出、バッチ通知送信、タイムアウトチェック、onAnswerトリガー
* Cloud Tasks: バッチの「時間経過チェック」や遅延タスクを安定実行
* LINE/X API: ユーザー通知（リンクはアプリを開く or deep link）

---

## 4. データモデル（主要コレクション）

（Firestoreドキュメント想定。IDは自動生成。）

### `users/{userId}`

* user_id, nickname, gender, birthdate, region, profile_tags[], linked:{line_id,x_id}, last_active_at, is_suspended

### `questions/{questionId}`

* question_id, user_id, title, content, choices[], category, region, is_public, gender_filter, age_filter:{min,max}, status (`waiting_for_answer` | `active_thread` | `closed`), created_at, updated_at

### `questions/{questionId}/batches/{batchId}`

* order (int), user_ids[], status (`waiting`|`sent`|`expired`|`canceled`), notified_at, expires_at, score_snapshot[]

### `threads/{threadId}` （もしくは questions/{questionId}/threads/{threadId}）

* thread_id, question_id, questioner_id, answerer_id, status (`active`|`closed`), created_at, updated_at

### `threads/{threadId}/messages/{messageId}`

* message_id, from (`questioner`|`answerer`|`system`), type (`initial_question`/`answer`/`followup_question`/`reverse_question`/`requestion`/`system`), text, meta (location/url/choice_index), created_at

### `matches/{matchId}`（オプションで履歴）

* match_id, question_id, answerer_id, match_score, status, created_at

### `notifications/{notifId}`

* notification_id, to_user_id, channel (`line`|`x`|`inapp`), payload, status (`pending`|`sent`|`failed`), sent_at

### `reports/{reportId}`（通報）

* report_id, target_type, target_id, reporter_id, reason, status, created_at

---

## 5. 状態遷移図（主要ステート）

### 質問ステータス（question.status）

```
waiting_for_answer -> active_thread -> closed
         ^                 |
         | (no answers)     | (thread closed)
         +-----------------+
```

### スレッドステータス（thread.status）

```
active -> closed
```

### バッチステータス（batch.status）

```
waiting -> sent -> (expired -> sent next batch) | canceled
```

> 補足：`waiting_for_answer` のまま一定期間（例：72h）で自動クローズする運用ルールを追加可能。

---

## 6. 主な処理フロー（シーケンス）

### 6.1 質問投稿時（同期/非同期トリガー）

1. Frontend `POST /questions` → Firestore `questions/{q}` 作成（status=waiting_for_answer）
2. Cloud Function `onCreate(questions)` がトリガー

   * 候補ユーザーを検索しスコアリング
   * バッチ分割して `questions/{q}/batches` を作成（status=waiting）
   * `sendBatch(questionId, batchOrder=1)` を呼ぶ

### 6.2 バッチ送信（sendBatch）

1. `batches/batch1.status` を `sent` に set（atomic）
2. 各 user_id に対し `notifications` ドキュメントを enqueue or push
3. Cloud Tasks に `checkBatchTimeout(questionId, batchId)` を遅延でスケジュール（timeout = X分）
4. ユーザーに通知（LINE/X/in-app）

### 6.3 回答受信（回答者が回答送信）

1. 回答者が `POST /questions/{q}/answers` を実施
2. Firestore に `answers` または `threads/{thread}/messages` として `type=answer` を作成
3. Cloud Function `onCreate(answer)` トリガー：

   * 該当 question の status を `active_thread`
   * 新規 `threads/{thread}` を作成（participants）
   * 既存の pending/sent batches を `canceled` に更新
   * 質問者へ通知（in-app/LINE/X）
4. thread での継続チャットが可能になる

### 6.4 バッチタイムアウトチェック（checkBatchTimeout）

* Cloud Task 実行時：

  * もし `thread` が既に生成されていたら `canceled`
  * batch の `expires_at` を過ぎて `sent` のまま answerが無ければ `expired` にし、`sendBatch(questionId, nextBatchOrder)` を実行

### 6.5 チャット内の逆質問・再質問

* 回答者がプリセット逆質問を送る：

  * 新規 message `type=reverse_question` 保存
  * 質問者へ通知
* 質問者が `requestion` を送る：

  * message 作成、回答者に通知
* 全て system が中継

---

## 7. マッチング＆通知アルゴリズム（擬似コード）

### 7.1 候補抽出＆スコアリング（擬似コード）

```pseudo
function buildCandidates(question):
  // 1. 地域フィルタ
  candidates = query users where region == question.region and not is_suspended

  // 2. カテゴリ/タグマッチ
  for user in candidates:
    score = 0
    if category in user.profile_tags: score += 0.4
    // 活動性ボーナス
    hours_since_active = now - user.last_active_at
    if hours_since_active < 24: score += 0.2
    // 過去回答率など
    score += min(user.past_answer_rate, 0.2)
    // 年齢/性別フィルタを満たすなら +0.1
    if question.gender_filter matches user.gender: score += 0.05
    user.score = score

  // 3. ソート降順
  sorted = sort candidates by score desc

  // 4. バッチ分割
  batches = chunk(sorted, batch_size) // batch_size = 10 (configurable)
  return batches
```

### 7.2 sendBatch（擬似コード）

```pseudo
function sendBatch(questionId, batchOrder):
  batch = getBatch(questionId, batchOrder)
  if batch.status != 'waiting': return

  // atomic update to prevent double-send
  update batch.status = 'sent', notified_at = now(), expires_at = now + TIMEOUT

  for userId in batch.user_ids:
    enqueueNotification(userId, questionId, channelPreferences(userId))

  scheduleCloudTask('checkBatchTimeout', {questionId, batchOrder}, delay=TIMEOUT)
```

---

## 8. バッチ配信／フォールバック戦略（詳細）

* **初回バッチサイズ**：5〜10（UX/スパムの観点で5推奨、運用で調整）
* **タイムアウト**：3〜10分（デフォルト5分）
* **最大バッチ数**：10（合計50〜100人程度）
* **フォールバック**：全バッチ消化後、管理者にアラート or 質問をPR表示して人力誘導

理由：LINE/Xはユーザー体験を損なわず、APIのレート制限回避のため少量ずつ通知する。

---

## 9. チャット（仲介）実装詳細

### 9.1 スレッド生成ルール

* 回答が送信された *瞬間* にスレッドを生成。
* スレッドは `threads/{threadId}` に格納し、participants は固定（質問者・回答者）。

### 9.2 メッセージ保存

* フロントは `threads/{threadId}/messages` に対する書き込み（Firestoreの場合 client SDK 直書きも可、ただしルール検査）
* 各メッセージは type を持ち、UIは type に応じてバブル表示・ボタン表示（逆質問ボタン等）を切り替える。

### 9.3 逆質問の制約

* 回答者が送れる逆質問は **プリセットのみ**（自由入力は塞ぐ）
* 理由：個人情報要求や診断的表現を防ぐため

### 9.4 既読／既応答管理

* `threads/{threadId}/read_at`（per participant）を設け、各ユーザーの既読タイムを保存

---

## 10. 同期・排他・整合性対策

### 10.1 競合条件

* 複数バッチがほぼ同時に `sendBatch` を実行する事故（重複通知）
* 複数回答者がほぼ同着で回答し、複数スレッド生成される恐れ

### 10.2 対策

* **Atomic Update**：batch.status の更新はトランザクション／atomic書き換えで実行（Firestore transaction）。
* **Leader Check**：Cloud Function は `if question.status != 'waiting_for_answer' then abort` をチェック。
* **First-writer wins**：回答受信時に `questions/{q}` の status を `active_thread` に更新するトランザクション内で thread を作成。最初の一件だけが成功する。失敗した回答（後から来たもの）は UI に「この質問は既にマッチ済み」と表示するか、別途回答として保存しない／保存してもマッチ対象としない。
* **Idempotency**：通知 enqueue / Cloud Tasks は idempotent key を付与（questionId+batchOrder）して重複実行を防止。

---

## 11. エラーハンドリング／再試行ポリシー

* 通知（LINE/X）送信失敗：`notifications` に `failed` 記録 → 再試行ポリシー（指数バックオフ×3） → 失敗が恒常化したら次候補へスキップ（ログ保管）
* Cloud Task 実行失敗：Cloud Tasks の retry 配置（try 5回）
* DBトランザクション失敗：クライアントにエラー返却しリトライ可能にする（例：UIで「もう一度送信」）
* 長時間未応答（全バッチ消化）：管理者通知／FAQ提示

---

## 12. セキュリティ・プライバシー要件

* **匿名化**：ユーザー間は相互に実ID/連絡先を見せない（nickname/年代/地域のみ）
* **Firestore Security Rules**：

  * `threads/{t}` の読み書きは participants のみ許可
  * `questions/{q}` の編集は投稿者のみ
* **コンテンツポリシー**：医療診断行為の禁止（system が message の監視）
* **通報機能**：即座に `reports` 登録、管理者ダッシュボードで確認
* **通信**：TLS必須、APIキー・OAuthトークンはSecret Managerで管理
* **ログ保存期間**：メッセージは保管方針により保持期間を定める（例：3年）

---

## 13. 運用・モニタリング・バックアップ

* **モニタリング**：Cloud Monitoring（関数エラー、通知失敗率、Task遅延）
* **アラート**：通知失敗率 > X%/1時間、Cloud Function error rate スロープ上昇時にSlack通知
* **バックアップ**：Firestore Export を日次で GCS に保存（保持ポリシー設定）
* **ログ**：通知ログ、マッチログをBigQueryへエクスポートして解析（回答率、応答時間の日次集計）

---

## 14. テスト方針

* **ユニットテスト**：マッチングロジック、バッチ分割、score計算の網羅
* **Integration**：Cloud Function トリガー（onCreate question、onCreate answer）と Firestore の連動
* **E2E**：擬似ユーザーで投稿→通知→回答→スレッド作成のフロー
* **Load Test**：高並列投稿（1000 q/h）で Cloud Tasks と通知のスルーキャパ確認
* **Security Test**：Firestoreルールの検査、ペネトレーション（XSS/Injection等）

---

## 15. 参考API一覧（主要）

* `POST /v1/questions` — 質問投稿
* `GET /v1/questions?region=&category=&is_public=` — 質問一覧
* `GET /v1/questions/{q}` — 質問詳細
* `POST /v1/questions/{q}/answers` — 回答送信（初回回答含む）
* `GET /v1/threads/{threadId}` — チャット取得
* `POST /v1/threads/{threadId}/messages` — チャット送信（followup/requestion など type 指定）
* `POST /v1/users/me` — プロフィール更新
* `POST /v1/webhooks/notify-line` — 内部通知エンドポイント（Cloud Function経由でLINE送信）
* `POST /v1/admin/reports` — 通報処理

（上記は設計例。実装時は OpenAPI で詳細定義すること）

---

## 16. 付録：Firestoreインデックス／推奨パラメータ

### 推奨インデックス（composite）

1. `questions`: `region ASC, category ASC, is_public ASC, created_at DESC`
2. `questions`: `user_id ASC, created_at DESC`
3. `answers`: `question_id ASC, created_at DESC`
4. `batches`: `question_id ASC, order ASC, status ASC`

### 設定パラメータ（Config）

* `BATCH_INITIAL_SIZE = 5`
* `BATCH_SUBSEQUENT_SIZE = 10`
* `BATCH_TIMEOUT_MIN = 3`（分）
* `BATCH_TIMEOUT_DEFAULT = 5`（分）
* `MAX_BATCHES = 10`
* `SCORE_WEIGHTS = { category:0.4, active:0.2, past_rate:0.2, tags:0.1, gender:0.05 }`

---

## 最後に（実装ロードマップ提案）

1. Firestore スキーマ作成 + セキュリティルール定義
2. `POST /questions` 実装 + Cloud Function for candidate building（単純版）
3. `sendBatch` 実装（通知stub） + Cloud Tasks タイムアウト動作確認
4. 回答送信 → thread 作成トランザクション実装
5. チャット UI（onSnapshot）実装 + メッセージtypeの扱い
6. LINE/X連携（実ID） + 通知の実運用テスト
7. モニタリング・バックアップ・運用手順を整備

---

必要であれば、この処理方式設計書から **OpenAPI定義、Cloud Function の Node.js サンプルコード（擬似）、Cloud Tasks 設定サンプル、Firestore セキュリティルール** を順に出力できます。どれを優先しますか？
